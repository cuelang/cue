cue eval ./pkg:foo

-- cue.mod/module.cue --
module: "example.com"

-- in.cue --
package foo

import "example.com/pkg"

#def: {
  _name: d: int
}

d: pkg.#D & { _name: d: int, _val: 4 }

// TODO: this should fail, as the _name restricting it is in this
// package.
e: pkg.#D & #def & {
  // This should fail as c is disallowed by the _name defined
  // in this package
  _name: c: int

  // This should not fail, as this is a different _val
  _val: f: int
}
f: e._val

-- pkg/bar.cue --
package pkg

#D: { _val: f: int }

-- out/eval --
Errors:
e._name: field `c` not allowed:
    ./in.cue:6:10
    ./in.cue:13:13
    ./in.cue:16:10

Result:
(_|_){
  // [eval]
  #def: (#struct){
    _name(:foo): (#struct){
      d: (int){ int }
    }
  }
  d: (#struct){
    _val(example.com:pkg): (#struct){
      f: (int){ int }
    }
    _name(:foo): (struct){
      d: (int){ int }
    }
    _val(:foo): (int){ 4 }
  }
  e: (_|_){
    // [eval]
    _val(example.com:pkg): (#struct){
      f: (int){ int }
    }
    _name(:foo): (_|_){
      // [eval]
      d: (int){ int }
      c: (_|_){
        // [eval] e._name: field `c` not allowed:
        //     ./in.cue:6:10
        //     ./in.cue:13:13
        //     ./in.cue:16:10
      }
    }
    _val(:foo): (struct){
      f: (int){ int }
    }
  }
  f: (_|_){
    // [eval] e._name: field `c` not allowed:
    //     ./in.cue:6:10
    //     ./in.cue:13:13
    //     ./in.cue:16:10
  }
}
-- out/compile --
--- in.cue
{
  #def: {
    _name: {
      d: int
    }
  }
  d: (〈import;"example.com/pkg"〉.#D & {
    _name: {
      d: int
    }
    _val: 4
  })
  e: ((〈import;"example.com/pkg"〉.#D & 〈0;#def〉) & {
    _name: {
      c: int
    }
    _val: {
      f: int
    }
  })
  f: 〈0;e〉._val
}
