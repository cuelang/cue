# DO NOT EDIT; generated by go run testdata/gen.go
#
#name: closing with comprehensions
#evalPartial
-- in.cue --
A :: {f1: int, f2: int}

for k, v in {f3: int} {
	a: A & {"\(k)": v}
}

B :: {
	for k, v in {f1: int} {
		"\(k)": v
	}
}

C :: {
	f1: _
	for k, v in {f1: int} {
		"\(k)": v
	}
}

D :: {
	for k, v in {f1: int} {
		"\(k)": v
	}
	...
}

E :: A & {
	for k, v in {f3: int} {
		"\(k)": v
	}
}
-- out/def --
E :: _|_ // field "f3" not allowed in closed struct
A :: {
	f1: int
	f2: int
}
a: _|_ // field "f3" not allowed in closed struct
B :: {
	f1: v
}
C :: {
	f1: {
		_
		v
		...
	}
}
D :: {
	f1: v
	...
}
-- out/legacy-debug --
<0>{E :: _|_(<1>.v:field "f3" not allowed in closed struct), A :: <2>C{f1: int, f2: int}, a: _|_(<3>.v:field "f3" not allowed in closed struct), B :: <4>C{f1: int}, C :: <5>C{f1: int}, D :: <6>{f1: int, ...}}
-- out/compile --
--- in.cue
{
  A:: {
    f1: int
    f2: int
  }
  for k, v in {
    f3: int
  } {
    a: (〈2;A〉 & {
      "\(〈2;k〉)": 〈2;v〉
    })
  }
  B:: {
    for k, v in {
      f1: int
    } {
      "\(〈1;k〉)": 〈1;v〉
    }
  }
  C:: {
    f1: _
    for k, v in {
      f1: int
    } {
      "\(〈1;k〉)": 〈1;v〉
    }
  }
  D:: {
    for k, v in {
      f1: int
    } {
      "\(〈1;k〉)": 〈1;v〉
    }
    ...
  }
  E:: (〈0;A〉 & {
    for k, v in {
      f3: int
    } {
      "\(〈1;k〉)": 〈1;v〉
    }
  })
}
