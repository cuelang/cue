{
  "comments": [
    {
      "key": {
        "uuid": "bc3f157f_b8302d7b",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 548,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-23T12:26:19Z",
      "side": 1,
      "message": "to",
      "range": {
        "startLine": 548,
        "startChar": 49,
        "endLine": 548,
        "endChar": 51
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "deb98cbf_ce1fea42",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 548,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "Removed this definition altogether. See below.",
      "parentUuid": "bc3f157f_b8302d7b",
      "range": {
        "startLine": 548,
        "startChar": 49,
        "endLine": 548,
        "endChar": 51
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "add74692_34eed8bf",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 615,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-23T19:10:29Z",
      "side": 1,
      "message": "Do you have examples of why this is the right approach?\n\nIn other words, given\n\n   a: {x: _|_} | 3\n\nit isn\u0027t obvious to me whether the right result is 3, or an error because I didn\u0027t constrain `a` enough.",
      "range": {
        "startLine": 614,
        "startChar": 0,
        "endLine": 615,
        "endChar": 21
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "badb0acb_efbc8eb9",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 615,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "TL;DR; Constraints should be definable across nodes, not just for a single node.\n\nEXAMPLE\nAs a simple case consider the following fuzzy set definitions:\n\na: {s:\"low\", v:0..25 } | { s: \"medium\", v:20..80 } | { s:\"high\", v:75..100 }\n\nUnifying this with { s: \"medium\" } should remove the first and last results, which happens if we adopt the current definition. Not doing so, leaving {s:_|_, v:0.25}, for instance, would quickly cause configurations to become unsatisfiable in unexpected ways.\n\nBACKGROUND\nTraditionally unification of two graphs is defined to fail (be bottom) if unification of any of its edges (fields) fails, recursively. What I\u0027m describing in the spec is essentially the same, but I just realized I was focussing too much on describing the implementation details. I changed the spec to be more like the traditional definition, which removes this failure concept.\n\nMORE ON DEFAULTS\nAlso note the overlap in the ranges. This example also shows the use for having defaults defined the way they are: unifying with { v:80 } will result in two values remaining allowing both \"medium\" and \"high\" for s. With the defaults mechanism as defined now, it will pick \"medium\", rather than fail.\n\nMy experience from a distant past with various systems using graph unification is that it is common to define both more and less specific variants of a struct, where the more specific one should be favored. \n\nSee reply below for an alternative that addresses your concerns, I think, and could be a useful alternative.",
      "parentUuid": "add74692_34eed8bf",
      "range": {
        "startLine": 614,
        "startChar": 0,
        "endLine": 615,
        "endChar": 21
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c3bda3b_e24ce97a",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 615,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T13:43:50Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "badb0acb_efbc8eb9",
      "range": {
        "startLine": 614,
        "startChar": 0,
        "endLine": 615,
        "endChar": 21
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4670b281_be135980",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 623,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-23T12:26:19Z",
      "side": 1,
      "message": "\"In other words, unification distributes over disjunction.\"",
      "range": {
        "startLine": 621,
        "startChar": 0,
        "endLine": 623,
        "endChar": 6
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ee6769bc_6e69cc79",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 623,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4670b281_be135980",
      "range": {
        "startLine": 621,
        "startChar": 0,
        "endLine": 623,
        "endChar": 6
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cc856706_77e47c77",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 651,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-23T12:26:19Z",
      "side": 1,
      "message": "eliminating",
      "range": {
        "startLine": 651,
        "startChar": 6,
        "endLine": 651,
        "endChar": 17
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f6a9276_d531fd89",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 651,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cc856706_77e47c77",
      "range": {
        "startLine": 651,
        "startChar": 6,
        "endLine": 651,
        "endChar": 17
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "96477686_23b86f51",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 665,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-23T12:26:19Z",
      "side": 1,
      "message": "You specified an order for unifying disjunctions, so why the talk about different orders?",
      "range": {
        "startLine": 662,
        "startChar": 1,
        "endLine": 665,
        "endChar": 33
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03e14139_371f8afd",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 665,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "I specified the order of the elements in the resulting disjunction when evaluating \"a \u0026 b\", where \"a\" and \"b\" are disjunctions. What I\u0027m requiring here is that the first value should be the same regardless of evaluating \"a \u0026 b\" or \"b \u0026 a\"",
      "parentUuid": "96477686_23b86f51",
      "range": {
        "startLine": 662,
        "startChar": 1,
        "endLine": 665,
        "endChar": 33
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd8c72e8_3ca04428",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 665,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T13:43:50Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "03e14139_371f8afd",
      "range": {
        "startLine": 662,
        "startChar": 1,
        "endLine": 665,
        "endChar": 33
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a310ece1_f4b582cd",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 676,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-23T19:10:29Z",
      "side": 1,
      "message": "It occurs to me that you need default values for _fields_, but not really for _disjunctions_. If you made that change, so that one would write\n\n  replicas: default(1)\n  replicas: int\n\n(or something more concise), then disjunctions could behave \"normally\" and you could drop all the complicated rules about whether they have a default value and when it is used. The only case I think of where you need a disjunctive expression to have a default is integer literals, and you could just special-case those. That would be a small price to pay for the simplicity of pure disjunctions.",
      "range": {
        "startLine": 671,
        "startChar": 1,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "657cb94d_8aeff89e",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 676,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "I think the default() notation is too much typing (it is very pervasive). But I see your point. It separates concerns neatly.\n\nOne slight variant of your suggestion is to \"mark\" a value as being allowed as default in a disjunction and then at the end all values remaining marked as default are unified to define the default. One solution is to say the first value of a disjunction is implicitly default. I find that confusing syntactically, though (and thought about that before). But something like \n\n  replicas: * 1 | int\n\nwhere \"*\" marks an allowed default, could work.\n\nPROS:\n- minimal typing, and probably not too cumbersome even when default values are pervasive\n- will be trivial to define defaultless disjunctions (currently \"required(a | b)\")\n- can represent syntactically the internal bit to indicate \"defaultability\" that already exists to compute the definition currently in the spec.\n- removes several concepts from the spec (manifest failure, ordering wrt disjunctions, the required builtin)\n- I suspect this approach will also lead to better error messages.\n\nCONS (that are probably pros):\nWhat do the following mean?\n1. (* \"tcp\" | \"udp\" ) \u0026 ( \"tcp\" | \"udp\" )\n2. (* { a:3 } | {}) \u0026 ({ b:4 } | { b:3 } )\nFor 1. \"tcp\" should really remain the default after unification. So the default bit must be \"sticky\".\nBut for 2. the default mechanism becomes quite restrictive, but maybe that is good.\nSo 2 would mean:\n*{a:3,b:4} | *{a:3,b:3} | {b:4} | {b:3}\nand the default would be {a:3,b:4} \u0026 {a:3,b:3} \u003d\u003d _|_, meaning there is no default unless the user explicitly disambiguates b.\n\nEXAMPLE:\nThe example of earlier could then be written as:\n\na: {s:\"low\", v:0..25 } | { s: \"medium\", v:20..80 } | { s:\"high\", v:75..100 }\na s: \"low\" | *\"medium\" | \"high\"\n\npreferring the term \"medium\" over \"low\" or \"high\" if left a choice, leaving all other constraints as a pure disjunction.\n\nOPERATOR?:\nNext would be to define the appropriate operator. \"#\", \"$\", and \"@\" are out (reserved). \n\"*\" is syntactically unambiguous and has this nice check-the-box feel to it, but overloads the use of \"*\".\n\"\u003d\": used, but not in expressions. No shift needed. Captures meaning reasonably well.\n\"\\\": also no shift, could be a useful operator at some point, though.\n\"^\", \"?\", \"~\": unused, require shift\n\nSee CL  https://cue-review.googlesource.com/c/cue/+/1221",
      "parentUuid": "a310ece1_f4b582cd",
      "range": {
        "startLine": 671,
        "startChar": 1,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "484479d9_7c8a8764",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 676,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T13:59:31Z",
      "side": 1,
      "message": "Oh, that example doesn\u0027t work, but one could simply do\n\na: {s:\"low\", v:0..25 } | *{ s: \"medium\", v:20..80 } | { s:\"high\", v:75..100 }\n\nof course.\n\nPicking \"low\" over \"medium\" over \"high\" is more involved, though:\n\nOne solution:\n\na: {s:\"low\", v:0..19 } | {s: *\"low\"|\"medium\", v:20..25 } | { s: \"medium\", v:26..74 } | { s: *\"medium\"|\"high\", v:75..80 } | { s:\"high\", v:81..100 }\n\nAnother:\n\na: *{s:\"low\", v:0..25 } | (*{ s: \"medium\", v:20..80 } | { s:\"high\", v:75..100 })\n\nThe later example shows the importance of erasing the default mark for non-disjunctions.",
      "parentUuid": "657cb94d_8aeff89e",
      "range": {
        "startLine": 671,
        "startChar": 1,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34370f0e_e2742c3b",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 676,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T13:43:50Z",
      "side": 1,
      "message": "I\u0027d proceed as follows.\n\nFirst, find real examples where you need defaults in _disjunctions_ as opposed to fields. I haven\u0027t seen any yet.\n\nIf you can\u0027t find any, then consider having defaults only for fields. My proposed semantics, assuming an if-else construct, is that a field f with default d and value v (v being the unification of all v\u0027 where \"f: v\u0027\" is in the instance) is equivalent to:\n\n  f: v if v !\u003d _|_ else d\n\nIf you\u0027re not happy with limiting defaults to fields and you decide to continue with explicitly marking defaults in disjunctions, then write down the rules here to make sure they are simple and intuitive. Here is my take:\n\n -  One or more values in a disjunction can be _marked_. When a marked value is unified, the result is also marked. (When unification results in a single value, the mark is dropped, as single values cannot be marked.) \n\n -  If a disjunction appears in where a concrete value is required (that is, as an operand or in a location where it will be emitted), the result is the unification of its marked values.\n\nThe problem with the first clause is that it gives different results depending on evaluation order. For example,\n\n    (* 1..3 | 4) \u0026 1..2 \u0026 (1 | 2)\n\nDone left to right, the first unification is 1..2 (dropping the mark because it\u0027s not a disjunction), then the second gives 1 | 2. But if we unify the first and third operands first, we get (*1 | *2), which when unified with 1..2 yields itself.\n\nLast and least, syntax: I like * and many years of experience with C-like languages has show that people don\u0027t have a problem distinguishing prefix and infix *.",
      "parentUuid": "484479d9_7c8a8764",
      "range": {
        "startLine": 671,
        "startChar": 1,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0bec0e4_18ae9fab",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 676,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T13:44:56Z",
      "side": 1,
      "message": "Sorry, when I wrote this I hadn\u0027t read your other CL. Will comment there.",
      "parentUuid": "34370f0e_e2742c3b",
      "range": {
        "startLine": 671,
        "startChar": 1,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13a15ba3_fd874342",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 676,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T13:53:20Z",
      "side": 1,
      "message": "That is an interesting point, regarding order. That is of course unacceptable. We have defined 1..2 to be a disjunction of values, so it is not an issue here, but one can get the same argument with:  ( *1..3 | \"foo\" ) \u0026 int \u0026 ( 1 | 2).\n\nSo something needs some adjustment.",
      "parentUuid": "a0bec0e4_18ae9fab",
      "range": {
        "startLine": 671,
        "startChar": 1,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90fac8ac_e00e7bd0",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 676,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-27T18:09:32Z",
      "side": 1,
      "message": "\u003e f: v if v !\u003d _|_ else d\nThis would be an unresolvable evaluation cycle.\n\nI would not be opposed, though, to limiting the markers as field-level constructs. Added a TODO for considering this in new cl",
      "parentUuid": "13a15ba3_fd874342",
      "range": {
        "startLine": 671,
        "startChar": 1,
        "endLine": 676,
        "endChar": 0
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d486beba_4d81ae8d",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 693,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-23T12:26:19Z",
      "side": 1,
      "message": "You are showing evaluations here, not defaults.",
      "range": {
        "startLine": 692,
        "startChar": 1,
        "endLine": 693,
        "endChar": 34
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d6f618d_e8b95e37",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 693,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "Fixed.",
      "parentUuid": "d486beba_4d81ae8d",
      "range": {
        "startLine": 692,
        "startChar": 1,
        "endLine": 693,
        "endChar": 34
      },
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79274014_c3c8555f",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 698,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-24T12:49:19Z",
      "side": 1,
      "message": "With the alternative to defaults, this requirement will drop as well and we will probably not need something in its place, as the order in which defaults are defined will become irrelevant.",
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fcbab72_87676052",
        "filename": "doc/ref/spec.md",
        "patchSetId": 2
      },
      "lineNbr": 698,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T13:43:50Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "79274014_c3c8555f",
      "revId": "c8e3c13aa5b3634a2786243242c9a97ca9fa0f7d",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    }
  ]
}