{
  "comments": [
    {
      "key": {
        "uuid": "2183140d_778d9bb9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-03T22:07:09Z",
      "side": 1,
      "message": "I guess this property existed before with ranges: *0..5 | *5..10, but is now more apparent with unary constraints.\n\nHowever, whereas \u003e\u003d5 \u0026 \u003c\u003d5 simplifies to 5, \u003e\u003d5 | \u003c\u003d5 should simplify to, or is at least logically equivalent to, int.",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04411246_aa2e62c4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-03T22:08:47Z",
      "side": 1,
      "message": "int | float, to be precise.",
      "parentUuid": "2183140d_778d9bb9",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "00f2488c_3e5b0518",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-04T04:23:25Z",
      "side": 1,
      "message": "I agree with the technical details, but disagree about what these two lines should mean (what it\u0027s most useful for them to mean).\n\nLet\u0027s look at some other cases:\n```\na: \u003e\u003d5\na: *5 | int\n```\nHere I\u0027m sure we agree that the result for `a` is 5. The first line sets up a constraint which the default in the second line fulfills.\n\nNow consider\n```\na: \u003e\u003d5 | int\na: * 5 | int\n```\nThis doesn\u0027t change anything; the result is still 5. Both definitions give the same answer.\n\nNow consider\n```\na: * \u003e\u003d5 | int\na: * 5 | int\n```\nThe only difference here is that the first line has a preference for values \u003e\u003d 5, rather than a hard requirement as in my first example. It still seems to me that 5 is the best answer. These two constraints probably came together from two different configs, combined. Both configs will take any int for `a`. One config prefers that `a` is at least 5; the other has a more definite preference for exactly 5. It is hard to see why either config would be unhappy with 5. But the existing definition does not resolve `a`, leaving it at `\u003e\u003d 5`. The user would get an error at emit time, and I think they would be puzzled, since when they examine the config they will see a default of 5, with nothing contradicting that.",
      "parentUuid": "04411246_aa2e62c4",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0439da47_85284f22",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-08T17:26:14Z",
      "side": 1,
      "message": "But that is not the same as saying *\u003e\u003d5 | *\u003c\u003d5 defaults to 5, as these two values can be normalized to *int.\n\nOkay, I see where you are coming from. So we\u0027re back at the definition where the remaining values are unified to obtain the default value.\n\nThe problem was that this was not idempotent.\n\n*{a: 1}|{b: 1} default to {a: 1}, but \nnorm(*{a: 1}|{b: 1} \u0026 *{a: 1}|{b: 1}) \u003d\u003e *{a: 1}|*{b: 1} \u003d\u003e defaults to *{a: 1, b:1}.\n\nOne solution could be to only allow starring of concrete values.",
      "parentUuid": "00f2488c_3e5b0518",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c5d22786_cd40c142",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-09T18:47:30Z",
      "side": 1,
      "message": "My definition gives the same answer for \n\n  *{a:1}|{b:1}\n\nand for\n\n   (*{a:1}}{b:1}) \u0026 (*{a:1}}{b:1})\n\nIt says, first try dropping the unmarked items and if you don\u0027t get bottom, you\u0027re done. For the first you get\n\n   {a:1}\n\nimmediately, and for the second you get\n\n   {a:1} \u0026 {a:1}\n\nwhich is {a:1}.\n\nThere is no normalization in this definition. Normalization is a syntactic operation which tries to put an expression in a form closer to its true lattice point without changing its default. I\u0027m saying that for the definition at least, don\u0027t talk about syntax. Talking about marks syntactically doesn\u0027t seem to work out right. So never do algebra with marks. Instead, when it\u0027s time to actually get an answer (figure out which lattice point an expression denotes), examine the expression as a whole, semantically. First remove the unmarked parts, and see if that denotes something. If it does, you have a usable default value, so use it. If it doesn\u0027t, the marks are not helping, so erase them and see what you have.\n\nThe spec doesn\u0027t care how you implement this. It\u0027s giving only the semantics. The reason I think you can get away with not having an algebra for marks is that you have a completely functional language, so you never really have to simplify or reduce any expression until it\u0027s time to actually turn it into a concrete value.\n\n\"Inside\" each of the two steps of my definition -- the \"drop unmarked\" step and the \"erase marks\" step -- you have an expression with no marks. In that context you can use mark-free algebra to simplify. That doesn\u0027t require normalization, just the commutativity, associativity and distribution of \u0026 and |.\n\nSo let\u0027s look at this example again:\n\n  a: * \u003e\u003d5 | int\n  a: * \u003c\u003d5 | int \n\nWhen it\u0027s time to emit a, you get\n\n   (* \u003e\u003d5 | int) \u0026 (* \u003c\u003d5 | int)\n\nUsing my definition, first drop the unmarked elements and see what you get:\n\n    \u003e\u003d5 \u0026 \u003c\u003d5\n\nThat evaluates to (denotes) 5, so that is your answer.\n\nNote that in my definition you never encounter  \u003e\u003d5 | \u003c\u003d5, which I agree denotes int.\n\nIf instead the expression was\n\n   (* \u003e\u003d5 | int) \u0026 (* \u003c\u003d4 | int)\n\nthen dropping the unmarked elements results in bottom, so the marks are erased and the result is\n\n   (\u003e\u003d5 | int) \u0026 (\u003c\u003d4 | int)\n  \u003d int \u0026 int\n  \u003d int",
      "parentUuid": "0439da47_85284f22",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1aebe71e_75feb9aa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-10T11:28:33Z",
      "side": 1,
      "message": "\u003e That doesn\u0027t require normalization, just the commutativity, associativity and distribution of \u0026 and |.\n\nAnd other properties, like subsumption laws, so that (5 | int) becomes int.",
      "parentUuid": "c5d22786_cd40c142",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02fa24bb_22cb6751",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-10T17:23:45Z",
      "side": 1,
      "message": "I see now what you\u0027re saying. Let me think about it a bit more.",
      "parentUuid": "1aebe71e_75feb9aa",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2943371_9e51983b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-17T08:36:23Z",
      "side": 1,
      "message": "Gave it some more thought and don\u0027t think this will work either, as it breaks distributiveness, at least.\n\n(*1 | \"foo\") \u0026 string\n\nshould be `\"foo\"`, but with this rule I think it will be `1`.\n\nI don\u0027t think you can get around some kind of normalization, if only to make it easier to prove the approach has the ACID properties. This approach may be easy to explain, but it took me a while to comprehend it within terms of the formalism.",
      "parentUuid": "02fa24bb_22cb6751",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08ca72f5_6f11fd78",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-03T22:07:09Z",
      "side": 1,
      "message": "It wasn\u0027t fully obvious to me at first too, but it shows that the existing definition is correct. It would be strange for it to resolve to 5 if the default is equivalent to int.",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be6a7aa3_74c81885",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-09T18:47:30Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "08ca72f5_6f11fd78",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91b774da_54bae154",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 656,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-08T17:26:14Z",
      "side": 1,
      "message": "I guess I\u0027m not fully clear with what \"evaluates to\" means.",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50223440_966259a0",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 656,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-09T18:47:30Z",
      "side": 1,
      "message": "I mean denotes, in the semantics. The lattice point that the expression represents. Hopefully that is also what the interpreter evaluates the expression to.",
      "parentUuid": "91b774da_54bae154",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    }
  ]
}