{
  "comments": [
    {
      "key": {
        "uuid": "2183140d_778d9bb9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-03T22:07:09Z",
      "side": 1,
      "message": "I guess this property existed before with ranges: *0..5 | *5..10, but is now more apparent with unary constraints.\n\nHowever, whereas \u003e\u003d5 \u0026 \u003c\u003d5 simplifies to 5, \u003e\u003d5 | \u003c\u003d5 should simplify to, or is at least logically equivalent to, int.",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04411246_aa2e62c4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-03T22:08:47Z",
      "side": 1,
      "message": "int | float, to be precise.",
      "parentUuid": "2183140d_778d9bb9",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "00f2488c_3e5b0518",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-04T04:23:25Z",
      "side": 1,
      "message": "I agree with the technical details, but disagree about what these two lines should mean (what it\u0027s most useful for them to mean).\n\nLet\u0027s look at some other cases:\n```\na: \u003e\u003d5\na: *5 | int\n```\nHere I\u0027m sure we agree that the result for `a` is 5. The first line sets up a constraint which the default in the second line fulfills.\n\nNow consider\n```\na: \u003e\u003d5 | int\na: * 5 | int\n```\nThis doesn\u0027t change anything; the result is still 5. Both definitions give the same answer.\n\nNow consider\n```\na: * \u003e\u003d5 | int\na: * 5 | int\n```\nThe only difference here is that the first line has a preference for values \u003e\u003d 5, rather than a hard requirement as in my first example. It still seems to me that 5 is the best answer. These two constraints probably came together from two different configs, combined. Both configs will take any int for `a`. One config prefers that `a` is at least 5; the other has a more definite preference for exactly 5. It is hard to see why either config would be unhappy with 5. But the existing definition does not resolve `a`, leaving it at `\u003e\u003d 5`. The user would get an error at emit time, and I think they would be puzzled, since when they examine the config they will see a default of 5, with nothing contradicting that.",
      "parentUuid": "04411246_aa2e62c4",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0439da47_85284f22",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-08T17:26:14Z",
      "side": 1,
      "message": "But that is not the same as saying *\u003e\u003d5 | *\u003c\u003d5 defaults to 5, as these two values can be normalized to *int.\n\nOkay, I see where you are coming from. So we\u0027re back at the definition where the remaining values are unified to obtain the default value.\n\nThe problem was that this was not idempotent.\n\n*{a: 1}|{b: 1} default to {a: 1}, but \nnorm(*{a: 1}|{b: 1} \u0026 *{a: 1}|{b: 1}) \u003d\u003e *{a: 1}|*{b: 1} \u003d\u003e defaults to *{a: 1, b:1}.\n\nOne solution could be to only allow starring of concrete values.",
      "parentUuid": "00f2488c_3e5b0518",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c5d22786_cd40c142",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-09T18:47:30Z",
      "side": 1,
      "message": "My definition gives the same answer for \n\n  *{a:1}|{b:1}\n\nand for\n\n   (*{a:1}}{b:1}) \u0026 (*{a:1}}{b:1})\n\nIt says, first try dropping the unmarked items and if you don\u0027t get bottom, you\u0027re done. For the first you get\n\n   {a:1}\n\nimmediately, and for the second you get\n\n   {a:1} \u0026 {a:1}\n\nwhich is {a:1}.\n\nThere is no normalization in this definition. Normalization is a syntactic operation which tries to put an expression in a form closer to its true lattice point without changing its default. I\u0027m saying that for the definition at least, don\u0027t talk about syntax. Talking about marks syntactically doesn\u0027t seem to work out right. So never do algebra with marks. Instead, when it\u0027s time to actually get an answer (figure out which lattice point an expression denotes), examine the expression as a whole, semantically. First remove the unmarked parts, and see if that denotes something. If it does, you have a usable default value, so use it. If it doesn\u0027t, the marks are not helping, so erase them and see what you have.\n\nThe spec doesn\u0027t care how you implement this. It\u0027s giving only the semantics. The reason I think you can get away with not having an algebra for marks is that you have a completely functional language, so you never really have to simplify or reduce any expression until it\u0027s time to actually turn it into a concrete value.\n\n\"Inside\" each of the two steps of my definition -- the \"drop unmarked\" step and the \"erase marks\" step -- you have an expression with no marks. In that context you can use mark-free algebra to simplify. That doesn\u0027t require normalization, just the commutativity, associativity and distribution of \u0026 and |.\n\nSo let\u0027s look at this example again:\n\n  a: * \u003e\u003d5 | int\n  a: * \u003c\u003d5 | int \n\nWhen it\u0027s time to emit a, you get\n\n   (* \u003e\u003d5 | int) \u0026 (* \u003c\u003d5 | int)\n\nUsing my definition, first drop the unmarked elements and see what you get:\n\n    \u003e\u003d5 \u0026 \u003c\u003d5\n\nThat evaluates to (denotes) 5, so that is your answer.\n\nNote that in my definition you never encounter  \u003e\u003d5 | \u003c\u003d5, which I agree denotes int.\n\nIf instead the expression was\n\n   (* \u003e\u003d5 | int) \u0026 (* \u003c\u003d4 | int)\n\nthen dropping the unmarked elements results in bottom, so the marks are erased and the result is\n\n   (\u003e\u003d5 | int) \u0026 (\u003c\u003d4 | int)\n  \u003d int \u0026 int\n  \u003d int",
      "parentUuid": "0439da47_85284f22",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1aebe71e_75feb9aa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-10T11:28:33Z",
      "side": 1,
      "message": "\u003e That doesn\u0027t require normalization, just the commutativity, associativity and distribution of \u0026 and |.\n\nAnd other properties, like subsumption laws, so that (5 | int) becomes int.",
      "parentUuid": "c5d22786_cd40c142",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02fa24bb_22cb6751",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-10T17:23:45Z",
      "side": 1,
      "message": "I see now what you\u0027re saying. Let me think about it a bit more.",
      "parentUuid": "1aebe71e_75feb9aa",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2943371_9e51983b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-17T08:36:23Z",
      "side": 1,
      "message": "Gave it some more thought and don\u0027t think this will work either, as it breaks distributiveness, at least.\n\n(*1 | \"foo\") \u0026 string\n\nshould be `\"foo\"`, but with this rule I think it will be `1`.\n\nI don\u0027t think you can get around some kind of normalization, if only to make it easier to prove the approach has the ACID properties. This approach may be easy to explain, but it took me a while to comprehend it within terms of the formalism.",
      "parentUuid": "02fa24bb_22cb6751",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a750057_f0a34265",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-17T13:50:57Z",
      "side": 1,
      "message": "I didn\u0027t state the rule precisely. In the first phase, you drop unmarked items *only for disjuncts that have marked items*. That\u0027s similar to one of the clauses of normalization.\n\nSo \n   (*1 | \"foo\") \u0026 string\nbecomes\n   1 \u0026 string\nwhich is bottom.\n\nIn phase two we erase the marks, giving\n   (1 | \"foo\") \u0026 string\nwhich is \"foo\".\n\nBy the way, I reject arguments of the form \"this breaks \u003calgebraic property\u003e,\" because I don\u0027t believe that you need an algebra that works for *, and while it would be nice to have anyway, I don\u0027t think one is possible that preserves all the desired algebraic properties.\n\nI don\u0027t know what you mean by \"ACID properties\" in this context, but if you mean \"algebraic properties of commutativity, associativity and distribution\" then see above.\n\nTo restate our debate in different terms: I agree an algebra that included * would be best, but I don\u0027t believe there is one. I don\u0027t think what you have now is correct because I think it gives the wrong answer for expressions like\n\n   (* \u003e\u003d5 | int) \u0026 (* \u003c\u003d5 | int)\n\nwhich, as I\u0027ve argued above, should resolve to 5.",
      "parentUuid": "b2943371_9e51983b",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2496812_9e4ae411",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-20T01:16:33Z",
      "side": 1,
      "message": "I see, the resolution comes from the second phase. \n\nDo you think one can prove this approach is associative, commutative, idempotent and distributive?\n\nThe problem with a non-algebraic approach is that it is hard to reason about in implementations and it may limit flexibility in order of evaluation. Also, two-phase evaluation is somewhat cumbersome.\n\nSo just to be clear and see if I understand: \na: *1 | 2\na: 1 | 2\n\nwould evaluate to\n(*1 | 2) \u0026 (1 | 2) \u003d\u003e  \nstep1: 1 \u0026 _|_ \u003d\u003e _|_ \nstep2: (1 | 2) \u0026 (1 | 2) \u003d\u003e (1 | 2)\n\nIt seems a bit unfortunate that defaults marks can be erased like this. A template may define an enum of values without a default while a specialization of that template may want to add a default value.",
      "parentUuid": "5a750057_f0a34265",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "162466b4_283a4b4d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-20T02:16:48Z",
      "side": 1,
      "message": "\u003e Do you think one can prove this approach is associative, commutative, idempotent and distributive?\n\nI\u0027ll think about that. (I\u0027m on vacation this week—-perfect time to do it!)\n\n  (*1 | 2) \u0026 (1 | 2) \u003d\u003e\nstep 1: drop non-marked elements of a disjunction that has marked elements:\n   1 \u0026 (1 | 2) \u003d\u003e 1\nso the answer is 1.",
      "parentUuid": "c2496812_9e4ae411",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a763047b_43484338",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-20T09:21:25Z",
      "side": 1,
      "message": "That was not clear from the definition.\n\nSo, I think this is the same as saying that marks are \"non-sticky\", and that any conjunct that has no marks is implicitly marked (i.e. for a disjunction without marks, all values are marked, all other non-disjunctions are implicitly marked as well).\n\nA different way to view this altogether: \n\nEach value x is really two lattice points, say (v, d) where v subsumes d, and where d is referred to as the default. (v1, d1) \u0026 (v2, d2) is (v1\u0026v2, d1\u0026d2). Note that as v1\u0026v2 subsumes d1\u0026d2, the subsumption property is preserved without requiring any additional definitions. During manifestation, d is taken if it is not bottom, otherwise v is taken.\nA unification of x1 and x2 succeeds if v1\u0026v2 is not bottom.\n\nSyntactically, default values can be introduced with disjunctions, where the value pair is (all disjuncts, marked disjuncts) if a disjunctions has marks or (all disjuncts, all disjuncts) otherwise.\n\nI think this gives exactly the properties you want. It is trivially clear that default values will become more specific after unifying any two values. For instance, (int, \u003c\u003d5) \u0026 (int, \u003e\u003d5) \u003d\u003e (int, 5). Also (1|2) \u0026 (*1|2) becomes (1|2, 1|2) \u0026 (1|2, 1) \u003d\u003e (1|2, 1).\n\nIt also, except for syntax, completely separates the notion of defaults from disjunctions. Normalization of disjunctions is now a matter separate from normalization of default values. For instance, (\u003e\u003d5 | int, \u003e\u003d5 | 10) can trivially be normalized to (int, \u003e\u003d5) without having to worry about marks and what they mean.\n\nIn general, one could (roughly) view evaluation now as doing two evaluations in parallel using regular unification, without worrying about the concept of defaults. Sort of like the AMT tax, but picking the best option instead of the worst, and more fun. :)",
      "parentUuid": "162466b4_283a4b4d",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99fc0d43_2e1298d1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-21T12:34:07Z",
      "side": 1,
      "message": "Regarding the alternative view, one could even conceptually separate the marks from disjunctions:\n\nIn this case, a value v _may_ be associated with a default, denoted (v, d) (not CUE syntax). The rules would then be (all associative and commutative):\n\n (v1, d1) \u0026 v2       \u003d\u003e (v1\u0026v2, d1\u0026v2)\n (v1, d1) \u0026 (v2, d2) \u003d\u003e (v1\u0026v2, d1\u0026d2)\n\n (v1, d1) | v2       \u003d\u003e (v1|v2, d1)\n (v1, d1) | (v2, d2) \u003d\u003e (v1|v2, d1|d2)\n\n(In text: \nAny value `v` may be associated with a default value `d`, denoted `(v, d)` (not CUE syntax),\nwhere `d` must be in instance of `v` (`d ⊑ v`).\nThe rules for unifying and disjoining such values are as follows:\n\n  \u003cas above\u003e\n\nFor any other operation, such as arithmetic expressions, indices, slices, and selectors,\nthe value `(v, d)` yields `d` if it is not bottom, or `v` otherwise.\n)\n\nRules for markers:\n\n // only allowed in disjunction, but otherwise independent:\n *v        \u003d\u003e (v, v)  \n *(v1, d1) \u003d\u003e (v1, d1)  (noop)\n\n\n(In text: \nDefault values may be introduced within disjunctions. The terms of a disjunction may be marked with an asterisk `*`. Such a marker sets the default value of that value to itself, making it a default over non-marked disjuncts. The marker has no effect if a value already has an associated default.\n)\n\nThese two pieces of text would be sufficient. No need to talk about normalization in conjunction with defaults (as in your proposal) or rules for how marks carry over. Markers are only used to relate syntax to semantics, but are not involved at all in resolution itself. Operations on defaults can be defined in terms of binary expressions, instead of considering a sequence of disjuncts in its entirety. The latter always made me a bit squeamish.\n\nI think this writeup is semantically equivalent to your proposal, but as I find reasoning about markers quite tricky, I am not sure.\n\nIt may be good to also mention the rules of subsumption, which we do not do now.  \nRules of subsumption are quite easy\n\n- (v2, d2) ⊑ (v1, d1)  if v2 ⊑ v1 and d2 ⊑ d1\n- (v1, d1) ⊑ v         if v1 ⊑ v (note that by definition d1 ⊑ v1, so d1 ⊑ v1 ⊑ v)\n- v ⊑ (v1, d1)         if v ⊑ d1\n\nthe last one is so restrictive as v could still be made more specific by associating it with a default that is not subsumed by d1. Proof: \nby definition for any d ⊑ v, it holds that (v, d) ⊑ v, where the most general value is (v, v).\nGiven the subsumption rule for (v2, d2) ⊑ (v1, d1), from (v, v) ⊑ v ⊑ (v1, d1) it follows that v ⊑ d1 exactly defines the boundary of this subsumption.\n\nI\u0027m not sure about the noop rule, but had to pick something.\n\n *(a | *b) | (c | *d) \u003d\u003e (a|b|c|d, b|d) // not (a|b|c|d, a|b|d)\n *(a | *b) | c        \u003d\u003e (a|b|c, b)\n  (a | *b) | *c       \u003d\u003e (a|b|c, b|c)\n\nseems reasonable, but variants are possible. Maybe not ideal, but it is a simple rule.\n\nNote that defaults are preserved across references:\n\n a: int | *1\n b: a | *2   \u003d\u003e (int|1|2, 1|2) \u003d\u003e (int, 1|2)\n\nAlso note:\n\n a: int | *1\n b: int | *2\n c: a \u0026 b \u003d\u003e int | *_|_ (note the importance of the the last term)\n d: c | *3 \u003d\u003e (int| _|_ |3, _|_ | 3) \u003d\u003e (int, 3)\n\nAll seems quite reasonable.\n\nPeople will get funky. For instance, to discard a default:\n\n a: int | *1       // (int, 1)\n b: a \u0026 (_ | *_|_) // set default to bottom (int, 1) \u0026 (_, _|_) \u003d\u003e (int, _|_)\n c: b | *2         // set new default: (int, _|_) | (2, 2) \u003d\u003e (int|2, _|_|2) \u003d\u003e (int, 2)\n d: b | *b         // allow any default again in unification \u003d\u003e (int, int)\n\nor just\n\n c: (a \u0026 (_|*_|_)) | *2\n\nor\n\n ClearDefault \u003d *_|_ | _  // need to ensure formatter adds spaces to *_|_|_ :)\n c: ClearDefault\u0026a | *2\n\nAll not that great, but as far as abuse goes, it could be worse (one cannot set a new default for an existing field, of course, as it will be unified right back in).",
      "parentUuid": "a763047b_43484338",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4dad21b_4a693bf9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-03-02T21:30:27Z",
      "side": 1,
      "message": "\u003e I think this writeup is semantically equivalent to your proposal\n\nYes, I think it\u0027s a more elegant way to describe it. I think everything you have matches my more mechanical description, including the noop rule.\n\n\u003e Such a marker sets the default value of that value to itself, making it a default over non-marked disjuncts. \n\nThis is unclear. Maybe: \"The default value of a disjunction with marked terms is the disjunction of those marked terms.\" And immediately follow with a simple example.\n\nI don\u0027t know if clearing a default is necessarily abuse. Maybe it\u0027s a good thing?",
      "parentUuid": "99fc0d43_2e1298d1",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0e3c6f5_f13426ce",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-03-14T14:53:30Z",
      "side": 1,
      "message": "I\u0027ll write this all up in a separate CL.\n\nAgreed that being able to clear a default is not necessarily bad, and maybe good.",
      "parentUuid": "f4dad21b_4a693bf9",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cde09f7a_bb435f3f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-03-17T12:58:01Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "f0e3c6f5_f13426ce",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08ca72f5_6f11fd78",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-03T22:07:09Z",
      "side": 1,
      "message": "It wasn\u0027t fully obvious to me at first too, but it shows that the existing definition is correct. It would be strange for it to resolve to 5 if the default is equivalent to int.",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be6a7aa3_74c81885",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-09T18:47:30Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "08ca72f5_6f11fd78",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91b774da_54bae154",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 656,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-08T17:26:14Z",
      "side": 1,
      "message": "I guess I\u0027m not fully clear with what \"evaluates to\" means.",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50223440_966259a0",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 656,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-09T18:47:30Z",
      "side": 1,
      "message": "I mean denotes, in the semantics. The lattice point that the expression represents. Hopefully that is also what the interpreter evaluates the expression to.",
      "parentUuid": "91b774da_54bae154",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "168fa8d7_365ec36a",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 656,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-20T09:21:25Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "50223440_966259a0",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0f9154a8_cc56a0d5",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 663,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-21T12:34:07Z",
      "side": 1,
      "message": "Normalization is still relevant even if no defaults are involved. In this example, {a:1} is equivalent to the result, and it would be weird and logically wrong to treat it differently.\n\nWithout the interaction with defaults, this could arguably be seen as an implementation detail. But I think it is good to at least informally remark on it, for example by leaving this paragraph in possibly rephrasing it as:\n\nA disjunction is _normalized_ if there is no element\n`a` for which there is an element `b` such that `a ⊑ b`.\nA disjunction literal must be normalized, where marked elements are exempted from this rule as long as a disjunction defined by multiple marked disjuncts is itself normalized.\n\nThis rephrasing is a bit longer, but decouples the notion of normalization of disjunctions from markers and default values. The first sentence could be in the section of disjunction, whereas the second sentence could be put in the section about defaults. Notice the distinction here between disjunctions (the concept) and disjunction literals, where the latter allows markers defining default values whereas these are irrelevant to the former.\n\nThe second sentence forbids code like:\n\na: float | 1.0\nb: float | *\u003c\u003d5.0 | *1.0\n\netc. which seems like a good idea, as this will likely be an error and there is no good use for such definitions otherwise.",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69c1bbf5_ac2a7c4f",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 722,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-20T09:21:25Z",
      "side": 1,
      "message": "Would this not be \"tcp\" | \"udp\"?",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1eecf54d_699662dd",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 722,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-20T18:20:14Z",
      "side": 1,
      "message": "Never mind, considering your other response.",
      "parentUuid": "69c1bbf5_ac2a7c4f",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "401f121f_95a4680b",
        "filename": "doc/ref/spec.md",
        "patchSetId": 1
      },
      "lineNbr": 722,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-03-14T14:53:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1eecf54d_699662dd",
      "revId": "40b235c948687f6690dc4b2e2dd0f8a4cad618b4",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    }
  ]
}