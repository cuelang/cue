{
  "comments": [
    {
      "key": {
        "uuid": "1bc44f83_b711e622",
        "filename": "doc/ref/spec.md",
        "patchSetId": 3
      },
      "lineNbr": 1542,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-01T16:54:05Z",
      "side": 1,
      "message": "Suggestion: disallow this and other similar operations on open lists until there\u0027s a compelling use case. I think they are confusing.",
      "range": {
        "startLine": 1542,
        "startChar": 0,
        "endLine": 1542,
        "endChar": 37
      },
      "revId": "58cee9e7091566c82b29de47943570e7e9faa8c8",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "01637250_36414faa",
        "filename": "doc/ref/spec.md",
        "patchSetId": 3
      },
      "lineNbr": 1542,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-01T20:14:09Z",
      "side": 1,
      "message": "I think the sum is needed, as it may be the only way to grow an existing list. Then not allowing  multiply would be strange. But it may be useful to express open ended lists as disjunctions where the shortest allowed one is the default.\n\nAnother thing that came up related to Kubernetes is \"strategic merges\", i.e. mapping lists to maps, unify, and then back. This pattern is all over the place there.",
      "parentUuid": "1bc44f83_b711e622",
      "range": {
        "startLine": 1542,
        "startChar": 0,
        "endLine": 1542,
        "endChar": 37
      },
      "revId": "58cee9e7091566c82b29de47943570e7e9faa8c8",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c340452e_8aeb1c97",
        "filename": "doc/ref/spec.md",
        "patchSetId": 3
      },
      "lineNbr": 1542,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-01T21:03:03Z",
      "side": 1,
      "message": "I don\u0027t think it\u0027s strange to allow + and not *. Go strings do that.\n\nI don\u0027t understand the strategic merge pattern. You map `[a, b]` to `{0: a, 1: b}`? And then unify with what?\n\nOr is this just the de-duping algorithm: `[a, b, a] \u003d\u003e {a, b} \u003d\u003e [a, b]`?",
      "parentUuid": "01637250_36414faa",
      "range": {
        "startLine": 1542,
        "startChar": 0,
        "endLine": 1542,
        "endChar": 37
      },
      "revId": "58cee9e7091566c82b29de47943570e7e9faa8c8",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c5d9da02_d8892ce5",
        "filename": "doc/ref/spec.md",
        "patchSetId": 3
      },
      "lineNbr": 1542,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-01T21:21:16Z",
      "side": 1,
      "message": "Ah you mean not allow multiplication altogether. It is useful for things like 4*[byte] (for IPs), but that could be written as [byte, byte, byte, byte]. I clarified in the doc that open ended lists have a default, It is a bit weirder for sum, as the second argument remains open.\n\nYou map a list keyed to a field, like [{name: \"a\", ...}, {name: \"b\":, ...}] to { \"a\": { name: \"a\", ...}, \"b\": { name: \"b\", ... } }, unify with another list mapped the same, and then map back to a list. There are probably rules for preserving order, which values override (which CUE would not allow), etc\n\nIt would be nice to allow pre and post mappings in the language somehow. This is a very common thing, and unification formalisms are quite poor at handling lists.\n\nTo expand on the emit top-level pattern, one could allow something like (never mind the syntax for now):\n\nmyList: [ ...{ name: string } ]\n\n// before evaluation, the list is converted to a map like this\nmyList: \u003c- { \"\\(x.name)\" : x for x in myList }\n\n// after evaluation, it is converted back to this format.\nmyList: -\u003e [ x for x in myList ]\n\n\nSee https://github.com/cuelang/cue/issues/14.",
      "parentUuid": "c340452e_8aeb1c97",
      "range": {
        "startLine": 1542,
        "startChar": 0,
        "endLine": 1542,
        "endChar": 37
      },
      "revId": "58cee9e7091566c82b29de47943570e7e9faa8c8",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41360200_04f42e36",
        "filename": "doc/ref/spec.md",
        "patchSetId": 3
      },
      "lineNbr": 1548,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-02-01T16:54:05Z",
      "side": 1,
      "message": "Multiplication should distribute over disjunction, so int(1)..int(3) * [x] \u003d [x] | [x, x] | [x, x, x]. The hard part is figuring out what 1..3 * [x] means, since 1..3 includes many floats.",
      "range": {
        "startLine": 1546,
        "startChar": 5,
        "endLine": 1548,
        "endChar": 3
      },
      "revId": "58cee9e7091566c82b29de47943570e7e9faa8c8",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "247af09b_f546163d",
        "filename": "doc/ref/spec.md",
        "patchSetId": 3
      },
      "lineNbr": 1548,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-02-01T20:14:09Z",
      "side": 1,
      "message": "That is cute one. We can just require that the value must be an integer.\n\nSo far we have not allowed operands to be constraint by parameter types, but this is possible. Must be done consistently though.",
      "parentUuid": "41360200_04f42e36",
      "range": {
        "startLine": 1546,
        "startChar": 5,
        "endLine": 1548,
        "endChar": 3
      },
      "revId": "58cee9e7091566c82b29de47943570e7e9faa8c8",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    }
  ]
}