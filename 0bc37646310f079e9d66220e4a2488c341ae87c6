{
  "comments": [
    {
      "key": {
        "uuid": "1bacb1a5_0c02b62c",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 618,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "I think these all follow from the definition. You can state them, but clarify that they follow.",
      "range": {
        "startLine": 612,
        "startChar": 0,
        "endLine": 618,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57811b73_b0b7552d",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 618,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "Maybe duplicates, updated def, but not bottom. It is okay for a disjunction to have an element that is subsumed by another, for instance `int | 1`. Similarly, bottom could be a member of a disjunction if not explicitly disallowed.",
      "parentUuid": "1bacb1a5_0c02b62c",
      "range": {
        "startLine": 612,
        "startChar": 0,
        "endLine": 618,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf64cc86_0088c5a4",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 632,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 631,
        "startChar": 0,
        "endLine": 632,
        "endChar": 30
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1710a03_a478e7a4",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 632,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "removed mention of duplicates.",
      "parentUuid": "cf64cc86_0088c5a4",
      "range": {
        "startLine": 631,
        "startChar": 0,
        "endLine": 632,
        "endChar": 30
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c43ba642_c77c3f9c",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "Wouldn\u0027t this need to be\n\n   (VolumeType \"local\").Local\n\n? Otherwise (a) where does \u003cName\u003e come from and (b) VolumeType.Local is just some arbitrary struct -- why couldn\u0027t it unify with VolumeType.Secrets?",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e959dc0a_71b3e089",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "VolumeType: {\n    // assign a hidden field with unique value for each volume type\n    \u003cName\u003e: { _kind: Name }\n    Local: { /* fields for local volumes */ }\n    PersistentDisk: { /* fields for persistent volumes */ }\n    Secrets: { /* ditto */ }\n}\n\nexpands to:\n\nVolumeType: {\n    Local: { _kind: \"Local\", ... }\n    PersistentDisk: { _kind: \"PersistentDisk\", ... }\n    Secrets: { _kind: \"Secrets\", ... }\n}\n\n(For each field, Name gets bound to the field\u0027s name and the resulting struct gets unified to the fields value. Templates fields (e.g. { \u003cX\u003e: int }) are to structs, what list element types (e.g. [...int]) are to lists.\n\nI could have written: \n// All volume types must be structs with a namesake kind field.\nVolumeType \u003cName\u003e: { _kind: Name } \nVolumeType: {\n    Local: { /* fields for local volumes */ }\n    PersistentDisk: { /* fields for persistent volumes */ }\n    Secrets: { /* ditto */ }\n}\n\nSo in the disjunction, all volume types have a different _kind an can never unify. The user would have to constrain the fields enough such that only one alternative remains.",
      "parentUuid": "c43ba642_c77c3f9c",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd092aa2_a94ea9c1",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T18:43:39Z",
      "side": 1,
      "message": "OK. I think templates need more examples (not necessarily in the spec). I didn\u0027t appreciate fully how they work.",
      "parentUuid": "e959dc0a_71b3e089",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2462e057_8624b024",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T23:01:06Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "cd092aa2_a94ea9c1",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ecace47f_906d5642",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "As mentioned on the other CL, this implies that if the result isn\u0027t a disjunction, the mark is dropped, which I think breaks commutativity.",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b2af9b4_2f8480b1",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "Thinking about this more: commutativity is not really broken for the given examples: *1 | *2 would be equivalent to 1 | 2  (both fail if not disambiguated). Also, ( *1..3 | \"foo\" ) \u0026 int would still evaluate to *1..3, considering we defined 1..3 as disjunctions.\n\nThat said: (*{a:1} | {b:1}) \u0026 {b:2} \u0026 (*{c:1} | {d:1}) still produces different results.\nThe differences are almost eliminated with the variant described in the comments above, but not quite.",
      "parentUuid": "ecace47f_906d5642",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94b9442f_6ba2482a",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T15:08:55Z",
      "side": 1,
      "message": "Looking at it quickly: I can see two possible fixes:\n1) When unifying two disjunction only elements resulting from unifying two marked elements are marked.\nAs a result: (*\"tcp\"|\"udp\") \u0026 (\"udp\"|\"tcp\") is now _|_ (ambiguous). But maybe that is not so bad as I thought before.\nAnother advantage: unifying \"{a: 1} | *{b: 1}\" with itself will keep the same value, so also keeping idempotence as well!:\n\n{a: 1} | *{b: 1}\nWith 1)\n{a:1} | {a:1,b:1} | *{b:1} -\u003e represents same set of values, same default\n\nOtherwise)\n{a:1} | {a:1,b:1} | *{a:1,b:1} | *{b:1} -\u003e {a:1,b:1} same values, different default!\n\n\n2) Don\u0027t discard any marks before a value is referred to. This doesn\u0027t solve the additional idempotence issue, though.\n\nNumber 1 wins.",
      "parentUuid": "9b2af9b4_2f8480b1",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49dd2d1b_3371dc4c",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T18:43:39Z",
      "side": 1,
      "message": "If you also require that disjunction literals have at most one marked disjunct, then (1) implies that all disjunctions have at most one. Which is easier to think about (for me).\n\nUnfortunately this breaks things like\n\n  [1, 2][(*1 | 2 | int) \u0026 1..5]\n\nbut maybe that\u0027s okay because they never come up in practice.",
      "parentUuid": "94b9442f_6ba2482a",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4322382_e1c3e5ff",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T23:01:06Z",
      "side": 1,
      "message": "I don\u0027t think it makes sense to require that. In some cases one will want to force the user to make a choice and not have a default. That is one of the appeals of this approach.\n\n\u003e Unfortunately this breaks things like\n\u003e    [1, 2][(*1 | 2 | int) \u0026 1..5]\n\nYes, that might be broken. But I think that is okay, indeed.\nThere may be workarounds, though: if we do not qualify ranges as a disjunction, or, at least make it qualify as a single value. If we allow *a | (*b | c) to mean the original semantics expressed with the new approach, that would be justifiable. Also, types and ranges should be treated equivalently in this matter.",
      "parentUuid": "49dd2d1b_3371dc4c",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    }
  ]
}