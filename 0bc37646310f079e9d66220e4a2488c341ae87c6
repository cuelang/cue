{
  "comments": [
    {
      "key": {
        "uuid": "1bacb1a5_0c02b62c",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 618,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "I think these all follow from the definition. You can state them, but clarify that they follow.",
      "range": {
        "startLine": 612,
        "startChar": 0,
        "endLine": 618,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57811b73_b0b7552d",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 618,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "Maybe duplicates, updated def, but not bottom. It is okay for a disjunction to have an element that is subsumed by another, for instance `int | 1`. Similarly, bottom could be a member of a disjunction if not explicitly disallowed.",
      "parentUuid": "1bacb1a5_0c02b62c",
      "range": {
        "startLine": 612,
        "startChar": 0,
        "endLine": 618,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "700cbb09_f733cf92",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 618,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-30T13:38:23Z",
      "side": 1,
      "message": "Text removed. It is now implied by normalization (which is necessary for defaults to work).",
      "parentUuid": "57811b73_b0b7552d",
      "range": {
        "startLine": 612,
        "startChar": 0,
        "endLine": 618,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cf64cc86_0088c5a4",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 632,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 631,
        "startChar": 0,
        "endLine": 632,
        "endChar": 30
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1710a03_a478e7a4",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 632,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "removed mention of duplicates.",
      "parentUuid": "cf64cc86_0088c5a4",
      "range": {
        "startLine": 631,
        "startChar": 0,
        "endLine": 632,
        "endChar": 30
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13ae7108_44e17eb6",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 632,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-30T13:38:23Z",
      "side": 1,
      "message": "Removed. Removal is only relevant for defaults and this mechanism is covered by normalization.",
      "parentUuid": "c1710a03_a478e7a4",
      "range": {
        "startLine": 631,
        "startChar": 0,
        "endLine": 632,
        "endChar": 30
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c43ba642_c77c3f9c",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "Wouldn\u0027t this need to be\n\n   (VolumeType \"local\").Local\n\n? Otherwise (a) where does \u003cName\u003e come from and (b) VolumeType.Local is just some arbitrary struct -- why couldn\u0027t it unify with VolumeType.Secrets?",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e959dc0a_71b3e089",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "VolumeType: {\n    // assign a hidden field with unique value for each volume type\n    \u003cName\u003e: { _kind: Name }\n    Local: { /* fields for local volumes */ }\n    PersistentDisk: { /* fields for persistent volumes */ }\n    Secrets: { /* ditto */ }\n}\n\nexpands to:\n\nVolumeType: {\n    Local: { _kind: \"Local\", ... }\n    PersistentDisk: { _kind: \"PersistentDisk\", ... }\n    Secrets: { _kind: \"Secrets\", ... }\n}\n\n(For each field, Name gets bound to the field\u0027s name and the resulting struct gets unified to the fields value. Templates fields (e.g. { \u003cX\u003e: int }) are to structs, what list element types (e.g. [...int]) are to lists.\n\nI could have written: \n// All volume types must be structs with a namesake kind field.\nVolumeType \u003cName\u003e: { _kind: Name } \nVolumeType: {\n    Local: { /* fields for local volumes */ }\n    PersistentDisk: { /* fields for persistent volumes */ }\n    Secrets: { /* ditto */ }\n}\n\nSo in the disjunction, all volume types have a different _kind an can never unify. The user would have to constrain the fields enough such that only one alternative remains.",
      "parentUuid": "c43ba642_c77c3f9c",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd092aa2_a94ea9c1",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T18:43:39Z",
      "side": 1,
      "message": "OK. I think templates need more examples (not necessarily in the spec). I didn\u0027t appreciate fully how they work.",
      "parentUuid": "e959dc0a_71b3e089",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2462e057_8624b024",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T23:01:06Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "cd092aa2_a94ea9c1",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0953f041_64925215",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 714,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-27T10:11:23Z",
      "side": 1,
      "message": "In tutorials and documentation I\u0027ve already started stressing the analogy to typed lists.\n\nAnother key thing to realize that types are constraints, and that constraints generate and thus act like templates.",
      "parentUuid": "2462e057_8624b024",
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ecace47f_906d5642",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T14:00:24Z",
      "side": 1,
      "message": "As mentioned on the other CL, this implies that if the result isn\u0027t a disjunction, the mark is dropped, which I think breaks commutativity.",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b2af9b4_2f8480b1",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T14:34:22Z",
      "side": 1,
      "message": "Thinking about this more: commutativity is not really broken for the given examples: *1 | *2 would be equivalent to 1 | 2  (both fail if not disambiguated). Also, ( *1..3 | \"foo\" ) \u0026 int would still evaluate to *1..3, considering we defined 1..3 as disjunctions.\n\nThat said: (*{a:1} | {b:1}) \u0026 {b:2} \u0026 (*{c:1} | {d:1}) still produces different results.\nThe differences are almost eliminated with the variant described in the comments above, but not quite.",
      "parentUuid": "ecace47f_906d5642",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94b9442f_6ba2482a",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T15:08:55Z",
      "side": 1,
      "message": "Looking at it quickly: I can see two possible fixes:\n1) When unifying two disjunction only elements resulting from unifying two marked elements are marked.\nAs a result: (*\"tcp\"|\"udp\") \u0026 (\"udp\"|\"tcp\") is now _|_ (ambiguous). But maybe that is not so bad as I thought before.\nAnother advantage: unifying \"{a: 1} | *{b: 1}\" with itself will keep the same value, so also keeping idempotence as well!:\n\n{a: 1} | *{b: 1}\nWith 1)\n{a:1} | {a:1,b:1} | *{b:1} -\u003e represents same set of values, same default\n\nOtherwise)\n{a:1} | {a:1,b:1} | *{a:1,b:1} | *{b:1} -\u003e {a:1,b:1} same values, different default!\n\n\n2) Don\u0027t discard any marks before a value is referred to. This doesn\u0027t solve the additional idempotence issue, though.\n\nNumber 1 wins.",
      "parentUuid": "9b2af9b4_2f8480b1",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49dd2d1b_3371dc4c",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-01-26T18:43:39Z",
      "side": 1,
      "message": "If you also require that disjunction literals have at most one marked disjunct, then (1) implies that all disjunctions have at most one. Which is easier to think about (for me).\n\nUnfortunately this breaks things like\n\n  [1, 2][(*1 | 2 | int) \u0026 1..5]\n\nbut maybe that\u0027s okay because they never come up in practice.",
      "parentUuid": "94b9442f_6ba2482a",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4322382_e1c3e5ff",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-26T23:01:06Z",
      "side": 1,
      "message": "I don\u0027t think it makes sense to require that. In some cases one will want to force the user to make a choice and not have a default. That is one of the appeals of this approach.\n\n\u003e Unfortunately this breaks things like\n\u003e    [1, 2][(*1 | 2 | int) \u0026 1..5]\n\nYes, that might be broken. But I think that is okay, indeed.\nThere may be workarounds, though: if we do not qualify ranges as a disjunction, or, at least make it qualify as a single value. If we allow *a | (*b | c) to mean the original semantics expressed with the new approach, that would be justifiable. Also, types and ranges should be treated equivalently in this matter.",
      "parentUuid": "49dd2d1b_3371dc4c",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ec535bc_37b54859",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-27T10:11:23Z",
      "side": 1,
      "message": "See latest update. Things are narrowing down neatly now, I think.",
      "parentUuid": "d4322382_e1c3e5ff",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ec140a2_944e6a68",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-27T10:32:17Z",
      "side": 1,
      "message": "BTW, another nice consequence of the currently preferred definition is that, for instance,\n\nbool \u003d\u003d true | false\n\nPreviously that was not the case as bool does not default to true or false.\n\nThis allows us to express CUE in itself in terms of sets whereas this was previously not possible.",
      "parentUuid": "3ec535bc_37b54859",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64428687_8b97ae85",
        "filename": "doc/ref/spec.md",
        "patchSetId": 4
      },
      "lineNbr": 738,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2019-01-30T13:38:23Z",
      "side": 1,
      "message": "The latest definition should be fully commutative and idempotent, also for defaults. (*2|3) \u0026 2..3, (*2|3) \u0026 (2|3), and (2|3) \u0026 (*2|3), now all give the same result. true|false and bool are now equivalent (it may be that the definition allows errors to be triggered at different spots, but logically they are the same).",
      "parentUuid": "1ec140a2_944e6a68",
      "range": {
        "startLine": 734,
        "startChar": 1,
        "endLine": 738,
        "endChar": 0
      },
      "revId": "0bc37646310f079e9d66220e4a2488c341ae87c6",
      "serverId": "cf2d04e9-fd44-3a25-9e02-2b093b5119d7",
      "unresolved": false
    }
  ]
}